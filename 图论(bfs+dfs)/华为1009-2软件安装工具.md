## 题目内容

有一个比较复杂的软件系统需要部署到客户提供的服务器上。该软件系统的安装过程非常繁琐，为了降低操作成本，需要开发一个工具实现自动化部署。

软件的安装过程可以分成若干个小步骤，某些步骤间存在依赖关系，被依赖的步骤必须先执行完，才能执行后续的安装步骤。满足依赖条件的多个步骤可以并行执行。

请你开发一个调度程序，以最短的时间完成软件的部署。

## 输入描述

第一行:总步骤数N

第二行:N个以空格分隔的整数，代表每个步骤所需的时间。该行所有整数之和不大于int32

第三行开始的N行:表示每个步骤所依赖的其它步骤的编号(编号从1开始，行号减2表示步骤的编号)，如果依赖多个步骤，用空格分隔。-1表示无依赖

测试用例确保各个安装步骤不会出现循环依赖。

## 输出描述

1个数字，代表最短执行时间。

## 样例

### 样例1

#### 输入

```
4
6 2 1 2
-1
-1
1
3
```

#### 输出

```
9
```

#### 说明

一共4个步骤。

每个步骤所需的时间分别为6 2 1 2

1步骤和2步骤无依赖，可并发执行;3步骤依赖步骤1;4步骤依赖步骤3

总的最小执行时间为6+1+2=9

![image-20241010113747423](%E5%8D%8E%E4%B8%BA1009-2%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7.assets/image-20241010113747423.png)

### 样例2

#### 输入

```
4
1 2 3 4
2 3
3
-1
1
```

#### 输出

```
10
```

#### 说明

1步骤依赖步骤2和3，2步骤依赖步骤3，3步骤无依赖，4步骤依赖步骤1

执行顺序为3 2 1 4 ，最小执行时间为3+2+1+4=10

![image-20241010113906528](%E5%8D%8E%E4%B8%BA1009-2%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7.assets/image-20241010113906528.png)
### 代码实现
#### 思路
建立关系 拓扑排序
graph[u]代表u节点依赖的前驱节点
dist[i]表示u节点开始以后需要花费的时间
4→3→1→2
6→3
dist[3]表示完成3以后所有节点的时间
遍历第一组时 dist[3] = dist[4]+cost[3]
遍历第二组时 dist[3] = max(dist[6]+cost[3], dist[4]+cost[3])也就是max(distp[6]+cost[3],dist[3])

```C++
#include <bits/stdc++.h>

using namespace std;

int main(){
    int n;
    cin >> n;
    vector<vector<int>> graph(n+1);
    vector<int> cost(n+1);
    for(int i = 1; i <= n; ++i){
    	cin >> cost[i];
	}
	vector<int> dist(n+1, -1); 
	vector<int> indegree(n+1);
	string s;
	getline(cin, s);
	stringstream line(s);
	for(int i = 1; i <= n; ++i){
		string s;
		getline(cin, s);
		stringstream line(s);
		int num;
		while(line >> num){
			if(num == -1){
				dist[i] = cost[i];
				break;
			}else{
				graph[i].push_back(num);//i节点需要依赖的前驱节点 
				indegree[num]++;//i入度++ 
			}
		}
	}
	//topsort 
	for(int i = 1; i <= n; ++i) {
		if(indegree[i] == 0 && graph[i].size() != 0) {
			queue<int> q;
			q.push(i);
			dist[i] = cost[i];
			while(!q.empty()){
				int u = q.front();
				q.pop();
				for(int v : graph[u]){
					indegree[v]--;
					if(indegree[v] == 0){
						q.push(v);
					}
					dist[v] = max(dist[v], dist[u]+cost[v]);//节点v开始以后还需要花费的时间 
				}
			}	
		}
	}
	int ans = 0;
	for(int i = 1; i <= n;++i){
		ans = max(ans, dist[i]);
	}
	cout << ans;
}
```
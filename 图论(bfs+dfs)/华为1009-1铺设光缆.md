## 题目内容

某运营商需要在某一区城铺设光缆，起点为机房，终点为某小区，整个区域以一个m*n的矩阵表示，光缆沿着矩阵的边铺设(不允许走对角线)，区域内有些节点可以经过，但有些节点(如图红色x的位置,输入时给定) 因为各种因素无法经过，起点的机房与终点的小区可能在区域内的任何位置，计算从机房到目标小区铺设光缆的最短距离(如果光缆无法从起点机房铺设到达目标小区，返回-1)。

![image-20241010104432573](%E5%8D%8E%E4%B8%BA1009-1%E9%93%BA%E8%AE%BE%E5%85%89%E7%BC%86.assets/image-20241010104432573.png)



## 输入描述

m矩阵宽(横轴点数量，例如图示为11，以0~10作为下标)

n矩阵高(纵轴点数量，例如图示为8，以0~7作为下标)

机房坐标(a1,a2)

目标小区坐标(b1,b2)

矩阵内不允许经过的节点数量k

依次为这些不允许经过的节点坐标

1 ≤ m, n ≤ 1000

0 ≤ k ≤ 100000

## 输出描述

从机房到目标小区铺设光缆的最短距离

## 样例

### 样例1

#### 输入

```
11
8
2 3
7 5
6
2 4
3 5
4 4
5 4
6 4
7 4
```

#### 输出

```
9
```

#### 说明

11*8的矩阵(横轴坐标0-10，纵轴坐标0-7)

起始点(机房)为坐标(2，3)

目标点(要连到的小区)为坐标(7，5)

矩阵内不允许经过的节点数为个6

依次给出这些不允许经过的节点坐标

### 样例2

#### 输入

```
3
3 
0 0
2 2
3
0 1
1 1
2 1
```

#### 输出

```
-1
```

### 代码实现
```C++
#include <bits/stdc++.h>

using namespace std;

int dx[4] = {0,0,-1,1};
int dy[4] = {-1,1,0,0};

void bfs(vector<vector<int>> & graph, vector<vector<int>> &distance,int x, int y){
    int n = graph.size();
    int m = graph[0].size();
    queue<pair<int,int>> q;
    q.push({x,y});
	while(!q.empty()){
    	auto cur = q.front();
    	q.pop();
    	int xxx = cur.first;
    	int yyy = cur.second;
		for(int i = 0; i < 4; ++i){
        	int nx = xxx + dx[i];
        	int ny = yyy + dy[i];
        	if(nx < 0 || nx >= n || ny < 0 || ny >= m || graph[nx][ny] == 1 || distance[nx][ny]!= -1) continue;
        	distance[nx][ny] = distance[xxx][yyy] + 1;
        	cout<<"x y "<<nx<<" "<<ny<<" "<<x<<" "<<y<<" "<<distance[nx][ny]<<" "<<distance[xxx][yyy]<<endl; 
        	q.push({nx,ny});
    	}		
	}

}
int main(){
    int m, n;
 	cin >> m >> n; 
    vector<vector<int>> graph(n, vector<int>(m,0));
    int a1, a2, b1, b2;
    cin >> a1 >> a2 >> b1 >> b2;
    int k;
    cin >> k;
    for(int i = 0; i < k; ++i){
    	int xx,yy;
    	cin >> xx >> yy;
    	graph[yy][xx] = 1;
	}
	cout<<graph.size()<<" "<<graph[0].size()<<endl;
    vector<vector<int>> distance(n,vector<int>(m,-1));
    distance[a2][a1] = 0;
    bfs(graph,distance,a2,a1);
    cout<<distance[b2][b1];
}
```